accumulate lists.
accumulate debug.
accumulate resolution_steps.

run :-
  problemCert Name F Cert (map Map) C,
  print "Running on problem ", print Name, print ":\n",
  resolveCert Map F Cert C.


run :-
  problem Name F Cert (map Map),
  print "Running on problem ", print Name, print ":\n",
  resolve Map F Cert.

run :-
  modalProblem Name ModalForm Cert,
  print "Running on problem ", print Name, print ":\n",
  modalToLK ModalForm LKForm,
  resolve [] (LKForm zero) Cert.

resolve [] F Cert :-
  if (entry_point Cert F)
      (print "Success\n==============================================\n")
		  (print "Fail\n", halt), fail.
resolve [(pr I C) | R] F Cert :-
  mapsto I C => resolve R F Cert.

resolveCert [] F Cert CertOut :-
  if (entry_point Cert F)
      (print "Success\n==============================================\n", term_to_string CertOut S, print S)
		  (print "Fail\n", halt), fail.
resolveCert [(pr I C) | R] F Cert  CertOut :-
  mapsto I C => resolve R F Cert.


  % Translation from Modal Language into FOL (assumes that the formula is already in nnf)

modalToLK (-- A) (x\ n (A x)).
modalToLK (++ A) (x\ p (A x)).

modalToLK (A !! B) (x\ ((DelA x) !-! (DelB x))) :- modalToLK A A', modalToLK B B', optdel A' DelA, optdel B' DelB.

modalToLK (A && B) (x\ ((DelA x) &-& (DelB x))) :- modalToLK A A', modalToLK B B', optdel A' DelA, optdel B' DelB.

modalToLK (dia (A)) (x\ (some (y\ ( (p (rel x y)) &+& (d-(DelA y)))))) :- modalToLK A A', optdel A' DelA.

modalToLK (box (A)) (x\ (all (y\ ( (n (rel x y)) !-! (DelA y))))) :- modalToLK A A', optdel A' DelA.


  % Operator that delays positively only non-literals
  
optdel A (x\ d+ (A x)) :- isCompForm (A x).
optdel A A :- isAtm (A x).